lines(y=ar[[2]][1:8,2], x=ar[[2]][1:8,1], type="l", col="maroon")
lines(y=jf[[2]][1:8,2], x=jf[[2]][1:8,1], type="l", col="gold")
lines(y=bs[[2]][1:8,2], x=jf[[2]][1:8,1], type="l", col="chocolate2")
lines(y=jg[[2]][1:8,2], x=jg[[2]][1:8,1], type="l", col="red")
par(mar=c(0,0,0,0))
plot(0,0, type="n", axes=FALSE, xlab="", ylab="")
legend("center",legend=c(db[[1]],jf[[1]],jg[[1]],jm[[1]],ar[[1]],bs[[1]],js[[1]]),
col=c("darkred","gold","red","blue4","maroon","chocolate2","forestgreen"),
lty = c(1,1,1,1,1,1,1))
dev.off()
layout(matrix(c(1,2), ncol=2, byrow=FALSE), widths = c(0.65,0.35))
plot(y=jm[[2]][1:8,2], x=jm[[2]][1:8,1], type="l", ylim=c(0,550), col="blue4",
xlab="Year", ylab="Cites", main="Citations per Year Among Selected WashU\n Poli Sci Faculty")
lines(y=js[[2]][1:8,2], x=js[[2]][1:8,1], type="l", col="forestgreen")
lines(y=db[[2]][1:8,2], x=js[[2]][1:8,1], type="l", col="darkred")
lines(y=ar[[2]][1:8,2], x=ar[[2]][1:8,1], type="l", col="maroon")
lines(y=jf[[2]][1:8,2], x=jf[[2]][1:8,1], type="l", col="gold")
lines(y=bs[[2]][1:8,2], x=jf[[2]][1:8,1], type="l", col="chocolate2")
lines(y=jg[[2]][1:8,2], x=jg[[2]][1:8,1], type="l", col="red")
par(mar=c(0,0,0,0))
plot(0,0, type="n", axes=FALSE, xlab="", ylab="")
legend("center",legend=c(db[[1]],jf[[1]],jg[[1]],jm[[1]],ar[[1]],bs[[1]],js[[1]]),
col=c("darkred","gold","red","blue4","maroon","chocolate2","forestgreen"),
lty = c(1,1,1,1,1,1,1))
library(squaresPack)
?squaresPack
remove.packages("squaresPack")
library(squaresPack)
multiplySquares(1,2)
remove.packages(squaresPack)
remove.packages("squaresPack")
alarm
alarm()
alarm()
alarm()
alarm()
alarm()
library(squaresPack)
multiplySquares(1,2)
setwd("C:\\Users\\drmiller1220\\Documents\\GitHub\\PS5") #setting working directory
library(foreign) # need library foreign to read in .dta file
anes_data <- read.dta("anes_timeseries_2012_stata12.dta") # load in data
anes_data_subset <- subset(anes_data, select=c(ft_dpc,pid_x,tea_supp_x,aidblack_self,
aidblack_dpc,presapp_job_x,
interest_attention,dem_raceeth_x,
gender_respondent_x))
anes_data_subset$ft_dpc <- ifelse(anes_data_subset$ft_dpc<0, NA, anes_data_subset$ft_dpc)
levels(anes_data_subset$pid_x) <- list("strong_dem"="1. Strong Democrat",
"weak_dem"="2. Not very strong Democract",
"ind_dem"="3. Independent-Democrat",
"ind"="4. Independent",
"ind_gop"="5. Independent-Republican",
"weak_gop"="6. Not very strong Republican",
"strong_gop"="7. Strong Republican")
levels(anes_data_subset$tea_supp_x) <- rev(list("strong_supp"="1. Strong support" ,
"weak_supp"="2. Not very strong support",
"lean_supp"="3. Lean toward supporting",
"indiff"="4. Do not lean either way",
"lean_opp"="5. Lean toward opposing",
"weak_opp"="6. Not very strong opposition",
"strong_opp"="7. Strong opposition"))
levels(anes_data_subset$presapp_job_x) <- rev(list("strong_app"="1. Approve strongly",
"weak_app"="2. Approve not strongly",
"weak_disapp"="4. Disapprove not strongly",
"strong_disapp"="5. Disapprove strongly"))
levels(anes_data_subset$interest_attention) <- rev(list("always"="1. Always",
"most"="2. Most of the time",
"half"="3. About half the time",
"some"="4. Some of the time",
"never"="5. Never"))
levels(anes_data_subset$dem_raceeth_x) <- list("white"="1. White non-Hispanic",
"black"="2. Black non-Hispanic",
"hispanic"="3. Hispanic",
"other"="4. Other non-Hispanic")
levels(anes_data_subset$gender_respondent_x) <- list("male"="1. Male",
"female"="2. Female")
anes_data_subset$aidblack_self <- ifelse(anes_data_subset$aidblack_self<0, NA, anes_data_subset$aidblack_self)
anes_data_subset$aidblack_dpc <- ifelse(anes_data_subset$aidblack_dpc<0, NA, anes_data_subset$aidblack_dpc)
anes_data_subset <- anes_data_subset[complete.cases(anes_data_subset),]
# removing all rows with an NA observation; committing evil casewise deletion
sample_rows <- sample(1:nrow(anes_data_subset), size = 0.5*nrow(anes_data_subset))
# get vector of numbers from 1 to the number of rows in the data set, and then sample
# a vector of numbers half that size with which to determine our training and test sets
training_set <- anes_data_subset[sample_rows,] # training set includes all rows sampled
test_set <- anes_data_subset[-sample_rows,] # test set includes all rows not sampled
# fitting an lm model including all subsetted variables except the aidblack for the
# respondent and Obama
lm_basic <- lm(ft_dpc ~ pid_x + tea_supp_x + presapp_job_x + interest_attention +
dem_raceeth_x + gender_respondent_x, data=training_set)
summary(lm_basic)
# fitting an lm model including all subsetted variables including the aidblack for the
# respondent and Obama
lm_race <- lm(ft_dpc ~ pid_x + tea_supp_x + presapp_job_x + interest_attention +
dem_raceeth_x + gender_respondent_x + aidblack_self +
aidblack_dpc, data=training_set)
summary(lm_race)
library(VGAM) # loading package needed for tobit regression
# fitting a tobit model including all subsetted variables except the aidblack for the
# respondent and Obama
tobit_basic <- vglm(ft_dpc ~ pid_x + tea_supp_x + presapp_job_x + interest_attention +
dem_raceeth_x + gender_respondent_x,
tobit(Lower = 0, Upper = 100, type.fitted="censored"),
data=training_set)
summary(tobit_basic)
# fitting a tobit model including all subsetted variables including the aidblack for the
# respondent and Obama
tobit_race <- vglm(ft_dpc ~ pid_x + tea_supp_x + presapp_job_x + interest_attention +
dem_raceeth_x + gender_respondent_x + aidblack_self +
aidblack_dpc, tobit(Lower = 0, Upper = 100, type.fitted="censored"),
data=training_set)
summary(tobit_race)
# storing predicted values based on test set observations; output of predict for tobit
# model is a data.frame, but is a vector for lm; for consistency, and for later use,
# we vectorize the tobit predicted values
lm_basic_predict <- predict(lm_basic, test_set, type="response")
lm_race_predict <- predict(lm_race, test_set, type="response")
tobit_basic_predict <- as.vector(predict(tobit_basic, test_set, type="response"))
tobit_race_predict <- as.vector(predict(tobit_race, test_set, type="response"))
true_values <- test_set$ft_dpc
predictions <- matrix(data=c(lm_basic_predict, lm_race_predict, tobit_basic_predict,
tobit_race_predict), ncol=4, dimnames=list(NULL,
c("lm_basic_predict", "lm_race_predict", "tobit_basic_predict",
"tobit_race_predict"))) # creating matrix of predictions
naive_values <- rep(median(test_set$ft_dpc), length(test_set$ft_dpc))
setClass('fitR', # creating an S4 'fitR' object
slots=c(statistics='matrix')
)
setGeneric("getfitR",
function(object="fitR")  {
standardGeneric("getfitR")
}
)
setMethod("getfitR", "fitR",
function(object){
return(object)
}
)
setGeneric(name="fitRstats",
def=function(true, predicted, naive, statistics, ...)
{standardGeneric("fitRstats")}
)
setMethod(f="fitRstats",
definition=function(true, predicted, naive=NULL, statistics="rmse", ...){
statistics_output <- NULL
abs_error <- apply(predicted, MAR=2, FUN=function(x) abs(x - true))
abs_pct_error <- apply(predicted, MAR=2, FUN=function(x) ifelse(x==0, pi/2, atan(abs((x - true)/true))))
baseline <- abs(naive-true)
if("rmse" %in% statistics){
rmse <- apply(abs_error, MAR=2, FUN=function(x) sqrt(sum(x^2)/length(x)))
cbind(statistics_output, rmse)
}
if("mad" %in% statistics){
mad <- apply(abs_error, MAR=2, FUN=function(x) median(x))
cbind(statistics_output, mad)
}
if("rmsle" %in% statistics){
rmsle <- apply(predicted, MAR=2, FUN=function(x) sqrt(sum((log(x+1)-log(true+1))^2)/length(true)))
cbind(statistics_output, rmsle)
}
if("mape" %in% statistics){
mape <- apply(abs_pct_error, MAR=2, FUN=function(x) sum(x)/length(x))
cbind(statistics_output, mape)
}
if("meape" %in% statistics){
meape <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x))
cbind(statistics_output, meape)
}
if("mrae" %in% statistics){
mrae <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x/baseline), baseline=baseline)
cbind(statistics_output, mrae)
}
colnames(statistics_output) <- ifelse(colnames(predicted)==NULL, paste0("Model ",1:length(dim(statistics_output)[2])), colnames(predicted))
return(new("fitR", statistics=statistics_output))
}
)
fitRstats(true=true_values, predicted=predictions, naive=naive_values, statistics = c("rmse","mad","meape",
"rmsle","mape"))
setMethod(f="fitRstats",
definition=function(true, predicted, naive=NULL, statistics="rmse", ...){
statistics_output <- NULL
abs_error <- apply(predicted, MAR=2, FUN=function(x) abs(x - true))
abs_pct_error <- apply(predicted, MAR=2, FUN=function(x) ifelse(x==0, pi/2, atan(abs((x - true)/true))))
baseline <- abs(naive-true)
if("rmse" %in% statistics){
rmse <- apply(abs_error, MAR=2, FUN=function(x) sqrt(sum(x^2)/length(x)))
cbind(statistics_output, rmse)
}
if("mad" %in% statistics){
mad <- apply(abs_error, MAR=2, FUN=function(x) median(x))
cbind(statistics_output, mad)
}
if("rmsle" %in% statistics){
rmsle <- apply(predicted, MAR=2, FUN=function(x) sqrt(sum((log(x+1)-log(true+1))^2)/length(true)))
cbind(statistics_output, rmsle)
}
if("mape" %in% statistics){
mape <- apply(abs_pct_error, MAR=2, FUN=function(x) sum(x)/length(x))
cbind(statistics_output, mape)
}
if("meape" %in% statistics){
meape <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x))
cbind(statistics_output, meape)
}
if("mrae" %in% statistics){
mrae <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x/baseline), baseline=baseline)
cbind(statistics_output, mrae)
}
#colnames(statistics_output) <- ifelse(colnames(predicted)==NULL, paste0("Model ",1:length(dim(statistics_output)[2])), colnames(predicted))
return(new("fitR", statistics=statistics_output))
}
)
fitRstats(true=true_values, predicted=predictions, naive=naive_values, statistics = c("rmse","mad","meape",
"rmsle","mape"))
setMethod(f="fitRstats",
definition=function(true, predicted, naive=NULL, statistics="rmse", ...){
statistics_output <- NULL
abs_error <- apply(predicted, MAR=2, FUN=function(x) abs(x - true))
abs_pct_error <- apply(predicted, MAR=2, FUN=function(x) ifelse(x==0, pi/2, atan(abs((x - true)/true))))
baseline <- abs(naive-true)
if("rmse" %in% statistics){
rmse <- apply(abs_error, MAR=2, FUN=function(x) sqrt(sum(x^2)/length(x)))
cbind(statistics_output, rmse)
}
if("mad" %in% statistics){
mad <- apply(abs_error, MAR=2, FUN=function(x) median(x))
cbind(statistics_output, mad)
}
if("rmsle" %in% statistics){
rmsle <- apply(predicted, MAR=2, FUN=function(x) sqrt(sum((log(x+1)-log(true+1))^2)/length(true)))
cbind(statistics_output, rmsle)
}
if("mape" %in% statistics){
mape <- apply(abs_pct_error, MAR=2, FUN=function(x) sum(x)/length(x))
cbind(statistics_output, mape)
}
if("meape" %in% statistics){
meape <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x))
cbind(statistics_output, meape)
}
if("mrae" %in% statistics){
mrae <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x/baseline), baseline=baseline)
cbind(statistics_output, mrae)
}
statistics_output <- as.matrix(statistics_output)
colnames(statistics_output) <- ifelse(colnames(predicted)==NULL, paste0("Model ",1:length(dim(statistics_output)[2])), colnames(predicted))
return(new("fitR", statistics=statistics_output))
}
)
setMethod(f="fitRstats",
definition=function(true, predicted, naive=NULL, statistics="rmse", ...){
statistics_output <- NULL
abs_error <- apply(predicted, MAR=2, FUN=function(x) abs(x - true))
abs_pct_error <- apply(predicted, MAR=2, FUN=function(x) ifelse(x==0, pi/2, atan(abs((x - true)/true))))
baseline <- abs(naive-true)
if("rmse" %in% statistics){
rmse <- apply(abs_error, MAR=2, FUN=function(x) sqrt(sum(x^2)/length(x)))
cbind(statistics_output, rmse)
}
if("mad" %in% statistics){
mad <- apply(abs_error, MAR=2, FUN=function(x) median(x))
cbind(statistics_output, mad)
}
if("rmsle" %in% statistics){
rmsle <- apply(predicted, MAR=2, FUN=function(x) sqrt(sum((log(x+1)-log(true+1))^2)/length(true)))
cbind(statistics_output, rmsle)
}
if("mape" %in% statistics){
mape <- apply(abs_pct_error, MAR=2, FUN=function(x) sum(x)/length(x))
cbind(statistics_output, mape)
}
if("meape" %in% statistics){
meape <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x))
cbind(statistics_output, meape)
}
if("mrae" %in% statistics){
mrae <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x/baseline), baseline=baseline)
cbind(statistics_output, mrae)
}
statistics_output <- as.matrix(statistics_output)
colnames(statistics_output) <- ifelse(colnames(predicted)==NULL, paste0("Model ",1:length(dim(statistics_output)[2])), colnames(predicted))
return(new("fitR", statistics=statistics_output))
}
)
fitRstats(true=true_values, predicted=predictions, naive=naive_values, statistics = c("rmse","mad","meape",
"rmsle","mape"))
setMethod(f="fitRstats",
definition=function(true, predicted, naive=NULL, statistics="rmse", ...){
statistics_output <- NULL
abs_error <- apply(predicted, MAR=2, FUN=function(x) abs(x - true))
abs_pct_error <- apply(predicted, MAR=2, FUN=function(x) ifelse(x==0, pi/2, atan(abs((x - true)/true))))
baseline <- abs(naive-true)
if("rmse" %in% statistics){
rmse <- apply(abs_error, MAR=2, FUN=function(x) sqrt(sum(x^2)/length(x)))
cbind(statistics_output, rmse)
}
if("mad" %in% statistics){
mad <- apply(abs_error, MAR=2, FUN=function(x) median(x))
cbind(statistics_output, mad)
}
if("rmsle" %in% statistics){
rmsle <- apply(predicted, MAR=2, FUN=function(x) sqrt(sum((log(x+1)-log(true+1))^2)/length(true)))
cbind(statistics_output, rmsle)
}
if("mape" %in% statistics){
mape <- apply(abs_pct_error, MAR=2, FUN=function(x) sum(x)/length(x))
cbind(statistics_output, mape)
}
if("meape" %in% statistics){
meape <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x))
cbind(statistics_output, meape)
}
if("mrae" %in% statistics){
mrae <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x/baseline), baseline=baseline)
cbind(statistics_output, mrae)
}
statistics_output <- as.matrix(statistics_output)
#colnames(statistics_output) <- ifelse(colnames(predicted)==NULL, paste0("Model ",1:length(dim(statistics_output)[2])), colnames(predicted))
return(new("fitR", statistics=statistics_output))
}
)
fitRstats(true=true_values, predicted=predictions, naive=naive_values, statistics = c("rmse","mad","meape",
"rmsle","mape"))
fitRstats <- function(true, predicted, naive=NULL, statistics="rmse"){
statistics_output <- NULL
abs_error <- apply(predicted, MAR=2, FUN=function(x) abs(x - true))
abs_pct_error <- apply(predicted, MAR=2, FUN=function(x) ifelse(x==0, pi/2, atan(abs((x - true)/true))))
baseline <- abs(naive-true)
if("rmse" %in% statistics){
rmse <- apply(abs_error, MAR=2, FUN=function(x) sqrt(sum(x^2)/length(x)))
statistics_output <- cbind(statistics_output, rmse)
}
if("mad" %in% statistics){
mad <- apply(abs_error, MAR=2, FUN=function(x) median(x))
statistics_output <- cbind(statistics_output, mad)
}
if("rmsle" %in% statistics){
rmsle <- apply(predicted, MAR=2, FUN=function(x) sqrt(sum((log(x+1)-log(true+1))^2)/length(true)))
statistics_output <- cbind(statistics_output, rmsle)
}
if("mape" %in% statistics){
mape <- apply(abs_pct_error, MAR=2, FUN=function(x) sum(x)/length(x))
statistics_output <- cbind(statistics_output, mape)
}
if("meape" %in% statistics){
meape <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x))
statistics_output <- cbind(statistics_output, meape)
}
if("mrae" %in% statistics){
mrae <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x/baseline))
statistics_output <- cbind(statistics_output, mrae)
}
rownames(statistics_output) <- ifelse(is.na(colnames(predicted)), paste0("Model ",1:dim(statistics_output)[1]), colnames(predicted))
return(statistics_output)
}
fitRstats(true=true_values, predicted=predictions, naive=naive_values, statistics = c("rmse","mad","meape",
"rmsle","mape"))
stat_results <- fitRstats(true=true_values, predicted=predictions, naive=naive_values, statistics = c("rmse","mad","meape",
"rmsle","mape"))
fitRstats <- function(true, predicted, naive=NULL, statistics="rmse"){
statistics_output <- NULL
abs_error <- apply(predicted, MAR=2, FUN=function(x) abs(x - true))
abs_pct_error <- apply(predicted, MAR=2, FUN=function(x) ifelse(x==0, pi/2, atan(abs((x - true)/true))))
baseline <- abs(naive-true)
if("rmse" %in% statistics){
rmse <- apply(abs_error, MAR=2, FUN=function(x) sqrt(sum(x^2)/length(x)))
statistics_output <- cbind(statistics_output, rmse)
}
if("mad" %in% statistics){
mad <- apply(abs_error, MAR=2, FUN=function(x) median(x))
statistics_output <- cbind(statistics_output, mad)
}
if("rmsle" %in% statistics){
rmsle <- apply(predicted, MAR=2, FUN=function(x) sqrt(sum((log(x+1)-log(true+1))^2)/length(true)))
statistics_output <- cbind(statistics_output, rmsle)
}
if("mape" %in% statistics){
mape <- apply(abs_pct_error, MAR=2, FUN=function(x) sum(x)/length(x))
statistics_output <- cbind(statistics_output, mape)
}
if("meape" %in% statistics){
meape <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x))
statistics_output <- cbind(statistics_output, meape)
}
if("mrae" %in% statistics){
mrae <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x/baseline))
statistics_output <- cbind(statistics_output, mrae)
}
statistics_output <- as.matrix(statistics_output)
rownames(statistics_output) <- ifelse(is.na(colnames(predicted)), paste0("Model ",1:dim(statistics_output)[1]), colnames(predicted))
return(statistics_output)
}
stat_results <- fitRstats(true=true_values, predicted=predictions, naive=naive_values, statistics = c("rmse","mad","meape",
"rmsle","mape"))
class(stat_results)
fitRstats <- NULL
setMethod(f="fitRstats",
definition=function(true, predicted, naive=NULL, statistics="rmse", ...){
statistics_output <- NULL
abs_error <- apply(predicted, MAR=2, FUN=function(x) abs(x - true))
abs_pct_error <- apply(predicted, MAR=2, FUN=function(x) ifelse(x==0, pi/2, atan(abs((x - true)/true))))
baseline <- abs(naive-true)
if("rmse" %in% statistics){
rmse <- apply(abs_error, MAR=2, FUN=function(x) sqrt(sum(x^2)/length(x)))
cbind(statistics_output, rmse)
}
if("mad" %in% statistics){
mad <- apply(abs_error, MAR=2, FUN=function(x) median(x))
cbind(statistics_output, mad)
}
if("rmsle" %in% statistics){
rmsle <- apply(predicted, MAR=2, FUN=function(x) sqrt(sum((log(x+1)-log(true+1))^2)/length(true)))
cbind(statistics_output, rmsle)
}
if("mape" %in% statistics){
mape <- apply(abs_pct_error, MAR=2, FUN=function(x) sum(x)/length(x))
cbind(statistics_output, mape)
}
if("meape" %in% statistics){
meape <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x))
cbind(statistics_output, meape)
}
if("mrae" %in% statistics){
mrae <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x/baseline), baseline=baseline)
cbind(statistics_output, mrae)
}
statistics_output <- as.matrix(statistics_output)
rownames(statistics_output) <- ifelse(colnames(predicted)==NULL, paste0("Model ",1:length(dim(statistics_output)[2])), colnames(predicted))
return(new("fitR", statistics=statistics_output))
}
)
setGeneric(name="fitRstats",
def=function(true, predicted, naive, statistics, ...)
{standardGeneric("fitRstats")}
)
setMethod(f="fitRstats",
definition=function(true, predicted, naive=NULL, statistics="rmse", ...){
statistics_output <- NULL
abs_error <- apply(predicted, MAR=2, FUN=function(x) abs(x - true))
abs_pct_error <- apply(predicted, MAR=2, FUN=function(x) ifelse(x==0, pi/2, atan(abs((x - true)/true))))
baseline <- abs(naive-true)
if("rmse" %in% statistics){
rmse <- apply(abs_error, MAR=2, FUN=function(x) sqrt(sum(x^2)/length(x)))
cbind(statistics_output, rmse)
}
if("mad" %in% statistics){
mad <- apply(abs_error, MAR=2, FUN=function(x) median(x))
cbind(statistics_output, mad)
}
if("rmsle" %in% statistics){
rmsle <- apply(predicted, MAR=2, FUN=function(x) sqrt(sum((log(x+1)-log(true+1))^2)/length(true)))
cbind(statistics_output, rmsle)
}
if("mape" %in% statistics){
mape <- apply(abs_pct_error, MAR=2, FUN=function(x) sum(x)/length(x))
cbind(statistics_output, mape)
}
if("meape" %in% statistics){
meape <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x))
cbind(statistics_output, meape)
}
if("mrae" %in% statistics){
mrae <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x/baseline), baseline=baseline)
cbind(statistics_output, mrae)
}
statistics_output <- as.matrix(statistics_output)
rownames(statistics_output) <- ifelse(colnames(predicted)==NULL, paste0("Model ",1:length(dim(statistics_output)[2])), colnames(predicted))
return(new("fitR", statistics=statistics_output))
}
)
stat_results <- fitRstats(true=true_values, predicted=predictions, naive=naive_values, statistics = c("rmse","mad","meape",
"rmsle","mape"))
setMethod(f="fitRstats",
definition=function(true, predicted, naive=NULL, statistics="rmse", ...){
statistics_output <- NULL
abs_error <- apply(predicted, MAR=2, FUN=function(x) abs(x - true))
abs_pct_error <- apply(predicted, MAR=2, FUN=function(x) ifelse(x==0, pi/2, atan(abs((x - true)/true))))
baseline <- abs(naive-true)
if("rmse" %in% statistics){
rmse <- apply(abs_error, MAR=2, FUN=function(x) sqrt(sum(x^2)/length(x)))
cbind(statistics_output, rmse)
}
if("mad" %in% statistics){
mad <- apply(abs_error, MAR=2, FUN=function(x) median(x))
cbind(statistics_output, mad)
}
if("rmsle" %in% statistics){
rmsle <- apply(predicted, MAR=2, FUN=function(x) sqrt(sum((log(x+1)-log(true+1))^2)/length(true)))
cbind(statistics_output, rmsle)
}
if("mape" %in% statistics){
mape <- apply(abs_pct_error, MAR=2, FUN=function(x) sum(x)/length(x))
cbind(statistics_output, mape)
}
if("meape" %in% statistics){
meape <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x))
cbind(statistics_output, meape)
}
if("mrae" %in% statistics){
mrae <- apply(abs_pct_error, MAR=2, FUN=function(x) median(x/baseline), baseline=baseline)
cbind(statistics_output, mrae)
}
statistics_output <- as.matrix(statistics_output)
!rownames(statistics_output) <- ifelse(colnames(predicted)==NULL, paste0("Model ",1:length(dim(statistics_output)[2])), colnames(predicted))
return(new("fitR", statistics=statistics_output))
}
)
stat_results <- fitRstats(true=true_values, predicted=predictions, naive=naive_values, statistics = c("rmse","mad","meape",
"rmsle","mape"))
stat_results <- fitRstats(true=true_values, predicted=predictions, naive=naive_values, statistics = c("rmse","mad","meape",
"rmsle","mape"))
stat_results <- fitRstats(true=true_values, predicted=predictions, naive=naive_values, statistics = c("rmse","mad","meape",
"rmsle","mape"))
